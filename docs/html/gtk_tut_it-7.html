<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
 <META NAME="GENERATOR" CONTENT="SGML-Tools 1.0.9">
 <TITLE>GTK Tutorial: Alcuni Widget</TITLE>
 <LINK HREF="gtk_tut_it-8.html" REL=next>
 <LINK HREF="gtk_tut_it-6.html" REL=previous>
 <LINK HREF="gtk_tut_it.html#toc7" REL=contents>
</HEAD>
<BODY BGCOLOR="#FFFFFF">
<A HREF="gtk_tut_it-8.html">Avanti</A>
<A HREF="gtk_tut_it-6.html">Indietro</A>
<A HREF="gtk_tut_it.html#toc7">Indice</A>
<HR NOSHADE>
<H2><A NAME="s7">7. Alcuni Widget</A></H2>

<H2><A NAME="ss7.1">7.1 L'Etichetta (Label)</A>
</H2>

<P>Le etichette sono molto usate in GTK, e sono relativamente semplici. Le
etichette non emettono segnali, dal momento che non hanno una finestra
X a loro assegnata. Se avete la necessit&agrave; di avere dei segnali o di fare
delle operazioni di clipping, potete usare il widget EventBox.
<P>Per creare una nuova etichetta, si usa:
<P>
<BLOCKQUOTE><CODE>
<PRE>
GtkWidget* gtk_label_new (char *str);
</PRE>
</CODE></BLOCKQUOTE>
<P>In cui l'unico argomento &egrave; la stringa che si vuole sia mostrata.
<P>Per cambiare il testo dell'etichetta dopo che &egrave; stata creata, si usa
la funzione:
<P>
<BLOCKQUOTE><CODE>
<PRE>
void gtk_label_set (GtkLabel  *label,
                    char      *str);
</PRE>
</CODE></BLOCKQUOTE>
<P>in cui il primo argomento &egrave; l'etichetta creata in precedenza (di cui si
fa il cast usando la macro GTK_LABEL()), mentre il secondo &egrave; la nuova
stringa.
<P>Nel caso, lo spazio necessario per la nuova stringa verr&agrave; regolato automaticamente.
<P>Per ottenere la stringa corrente si usa:
<P>
<BLOCKQUOTE><CODE>
<PRE>
void gtk_label_get (GtkLabel  *label,
                    char     **str);
</PRE>
</CODE></BLOCKQUOTE>
<P>in cui il primo argomento &egrave; l'etichetta che avete creato, e il secondo
&egrave; il valore di ritorno per la stringa.
<P>
<H2><A NAME="ss7.2">7.2 Il Widget Suggerimenti (Tooltips)</A>
</H2>

<P>I suggerimenti sono piccole stringhe di testo che spuntano quando lasciate il
puntatore su un bottone o un altro widget per qualche secondo. Sono piuttosto
semplici da usare, per cui ne dar&ograve; la spiegazione senza corredarla di esempi.
Se volede vedere un po' di codice, date un'occhiata al programma testgtk.c
distribuito con GTK.
<P>Con alcuni widget (per esempio con l'etichetta) i suggerimenti non funzionano.
<P>La prima chiamata che si usa per creare un nuovo tooltip &egrave; la seguente.
In una data funzione, &egrave; necessario chiamarla una sola volta: il <CODE>GtkTooltip</CODE>
che viene restituito da questa funzione pu&ograve; essere usato per creare suggerimenti
multipli.
<P>
<BLOCKQUOTE><CODE>
<PRE>
GtkTooltips *gtk_tooltips_new (void);
</PRE>
</CODE></BLOCKQUOTE>
<P>Una volta creato un nuovo suggerimento e il widget su cui lo volete usare,
basta usare la seguente chiamata per fare l'assegnazione:
<P>
<BLOCKQUOTE><CODE>
<PRE>
void gtk_tooltips_set_tip (GtkTooltips *tooltips,
                           GtkWidget   *widget,
                           const gchar *tip_text,
                           const gchar *tip_private);
</PRE>
</CODE></BLOCKQUOTE>
<P>Il primo argomento &egrave; il suggerimento che era gi&agrave; stato creato, che &egrave; seguito
dal widget da cui volete che spunti il suggerimento e dal testo che volete
venga mostrato. L'ultimo argomento pu&ograve; essere posto a NULL.
<P>Ecco un piccolo esempio:
<P>
<BLOCKQUOTE><CODE>
<PRE>
GtkTooltips *tooltips;
GtkWidget *button;
...
tooltips = gtk_tooltips_new ();
button = gtk_button_new_with_label ("button 1");
...
gtk_tooltips_set_tips (tooltips, button, "This is button 1", NULL);
</PRE>
</CODE></BLOCKQUOTE>

Ci sono anche altre funzioni che si usano con i suggerimenti. Eccone una lista
con una breve descrizione di quello che fanno.
<P>
<BLOCKQUOTE><CODE>
<PRE>
void gtk_tooltips_destroy    (GtkTooltips *tooltips);
</PRE>
</CODE></BLOCKQUOTE>
<P>Distrugge un suggerimento esistente.
<P>
<BLOCKQUOTE><CODE>
<PRE>
void gtk_tooltips_enable     (GtkTooltips *tooltips);
</PRE>
</CODE></BLOCKQUOTE>
<P>Abilita  un gruppo di suggerimenti disbilitato.
<P>
<BLOCKQUOTE><CODE>
<PRE>
void gtk_tooltips_disable    (GtkTooltips *tooltips);
</PRE>
</CODE></BLOCKQUOTE>
<P>Disabilita un gruppo di suggerimenti abilitato.
<P>
<BLOCKQUOTE><CODE>
<PRE>
void gtk_tooltips_set_delay  (GtkTooltips *tooltips,
                              gint         delay);
</PRE>
</CODE></BLOCKQUOTE>

Stabilisce quanti millisecondi si deve mantenere il puntatore sopra al
widget prima che venga mostrato il suggerimento. Il valore di difetto
&egrave; di 1000 millisecondi.
<P>
<BLOCKQUOTE><CODE>
<PRE>
void      gtk_tooltips_set_tips (GtkTooltips *tooltips,
                                 GtkWidget   *widget,
                                 gchar    *tips_text);
</PRE>
</CODE></BLOCKQUOTE>
<P>Cambia il testo di un suggerimento gi&agrave; esistente.
<P>
<BLOCKQUOTE><CODE>
<PRE>
void gtk_tooltips_set_colors (GtkTooltips *tooltips,
                              GdkColor    *background,
                              GdkColor    *foreground);
</PRE>
</CODE></BLOCKQUOTE>
<P>Assegna i colori di primo piano e di sfondo dei suggerimenti. (Non ho idea
di come si specifichino i colori).
<P>E questo &egrave; tutto riguardo alle funzioni relative ai suggerimenti. Pi&ugrave;
di quanto avreste mai voluto sapere :)
<P>
<P>
<H2><A NAME="ss7.3">7.3 La Barra di Avanzamento (Progress Bar)</A>
</H2>

<P>Le barre di avanzamento sono usate per mostrare lo stato di una operazione. Come potete
vedere nel frammento di codice qui sotto, sono piuttosto semplici da usare.
Ma prima vediamo come cominciare con la chiamata per creare una nuova progress
bar.
<P>
<BLOCKQUOTE><CODE>
<PRE>
GtkWidget *gtk_progress_bar_new (void);
</PRE>
</CODE></BLOCKQUOTE>
<P>Ora che la barra di avanzamento &egrave; stata creata, possiamo usarla..
<P>
<BLOCKQUOTE><CODE>
<PRE>
void gtk_progress_bar_update (GtkProgressBar *pbar, gfloat percentage);
</PRE>
</CODE></BLOCKQUOTE>
<P>Il primo argomento &egrave; la barra di avanzamento su cui volete lavorare, e il secondo
&egrave; la quantit&agrave; 'completato', cio&egrave; la quantit&agrave; di riempimento della progress
bar fra 0 e 100% (un numero reale fra 0 e 1).
<P>Le barre di avanzamento sono usate di solito con funzioni di timeout o altre di
questo tipo (vedi alla sezione 
<A HREF="gtk_tut_it-15.html#sec_timeouts">Timeouts, I/O and Idle Functions</A>) per dare l'illusione del multitasking. Tutte
usano la funzione gtk_progress_bar_update nello stesso modo.
<P>Ecco un esempio di barra di avanzamento, in cui l'aggiornamento avviene usando
dei timeout. Questo codice vi mostra anche come riinizializzare le
barre di avanzamento.
<P>
<BLOCKQUOTE><CODE>
<PRE>
/* progressbar.c */

#include &lt;gtk/gtk.h>

static int ptimer = 0;
int pstat = TRUE;

/* Questa funzione incrementa e aggiorna la barra di avanzamento, e la rimette
   a zero se pstat &egrave; FALSE */
gint progress (gpointer data)
{
    gfloat pvalue;
    
    /* ottiene il valore corrente della status bar */
    pvalue = GTK_PROGRESS_BAR (data)->percentage;
    
    if ((pvalue >= 1.0) || (pstat == FALSE)) {
        pvalue = 0.0;
        pstat = TRUE;
    }
    pvalue += 0.01;
    
    gtk_progress_bar_update (GTK_PROGRESS_BAR (data), pvalue);
    
    return TRUE;
}

/* Questa funzione segnala la riinizializzazione della 
   barra di avanzamento */
void progress_r (void)
{  
    pstat = FALSE;  
}

void destroy (GtkWidget *widget, gpointer data)
{
    gtk_main_quit ();
}

int main (int argc, char *argv[])
{
    GtkWidget *window;
    GtkWidget *button;
    GtkWidget *label;
    GtkWidget *table;
    GtkWidget *pbar;
    
    gtk_init (&amp;argc, &amp;argv);
    
    window = gtk_window_new (GTK_WINDOW_TOPLEVEL);
    
    gtk_signal_connect (GTK_OBJECT (window), "delete_event",
                        GTK_SIGNAL_FUNC (destroy), NULL);
    
    gtk_container_border_width (GTK_CONTAINER (window), 10);
    
    table = gtk_table_new(3,2,TRUE);
    gtk_container_add (GTK_CONTAINER (window), table);
    
    label = gtk_label_new ("Progress Bar Example");
    gtk_table_attach_defaults(GTK_TABLE(table), label, 0,2,0,1);
    gtk_widget_show(label);
    /* Crea una nuova barra di avanzamento, impacchettala nella tabella
       e mostrala */
    pbar = gtk_progress_bar_new ();
    gtk_table_attach_defaults(GTK_TABLE(table), pbar, 0,2,1,2);
    gtk_widget_show (pbar);
    
    /* Attiva un timeout che gestisca l'aggiornamento automatico della barra */
    ptimer = gtk_timeout_add (100, progress, pbar);
    
    /* Questo bottone segnala alla barra che deve essere resettata */
    button = gtk_button_new_with_label ("Reset");
    gtk_signal_connect (GTK_OBJECT (button), "clicked",
                        GTK_SIGNAL_FUNC (progress_r), NULL);
    gtk_table_attach_defaults(GTK_TABLE(table), button, 0,1,2,3);
    gtk_widget_show(button);
    
    button = gtk_button_new_with_label ("Cancel");
    gtk_signal_connect (GTK_OBJECT (button), "clicked",
                        GTK_SIGNAL_FUNC (destroy), NULL);
    
    gtk_table_attach_defaults(GTK_TABLE(table), button, 1,2,2,3);
    gtk_widget_show (button);
    
    gtk_widget_show(table);
    gtk_widget_show(window);
    
    gtk_main ();
    
    return 0;
}
</PRE>
</CODE></BLOCKQUOTE>
<P>In questo programmino ci sono quattro aree che riguardano il modo di
uso generale delle Barre di Avanzamento; le vediamo ora nell'ordine.
<P>
<BLOCKQUOTE><CODE>
<PRE>
pbar = gtk_progress_bar_new ();
</PRE>
</CODE></BLOCKQUOTE>
<P>Questo codice crea una nuova barra ciamata pbar.
<P>
<BLOCKQUOTE><CODE>
<PRE>
ptimer = gtk_timeout_add (100, progress, pbar);
</PRE>
</CODE></BLOCKQUOTE>
<P>Questo codice usa dei timeout per abilitare degli intervalli di tempo uguali.
Per usare le barre di avanzamento non &egrave; per&ograve; necessario servirsi di timeout.
<P>
<BLOCKQUOTE><CODE>
<PRE>
pvalue = GTK_PROGRESS_BAR (data)->percentage;
</PRE>
</CODE></BLOCKQUOTE>
<P>Qui si assegna a pvalue il valore corrente della percentuale di avanzamento.
<P>
<BLOCKQUOTE><CODE>
<PRE>
gtk_progress_bar_update (GTK_PROGRESS_BAR (data), pvalue);
</PRE>
</CODE></BLOCKQUOTE>
<P>Infine, questo codice aggiorna la barra di avanzamento con il valore di pvalue.
<P>Questo &egrave; tutto quanto c'&egrave; da sapere sulle barre di avanzamento, divertitevi.
<P>
<H2><A NAME="ss7.4">7.4 Dialoghi</A>
</H2>

<P>
<P>Il widget ``Dialogo'' &egrave; molto semplice: si tratta in realt&agrave; di una finestra
con alcuni elementi pre-impacchettati. La struttura di un dialogo &egrave; la
seguente:
<P>
<BLOCKQUOTE><CODE>
<PRE>
struct GtkDialog
{
      GtkWindow window;
    
      GtkWidget *vbox;
      GtkWidget *action_area;
};
</PRE>
</CODE></BLOCKQUOTE>
<P>Come potete vedere, crea semplicemente una finestra vi inserisce una vbox
in cima, poi un separatore e infine una hbox come ``area di azione''.
<P>Un Dialogo pu&ograve; essere utilizzato per messaggi per l'utente e
altri scopi simili. E' un widget molto essenziale, che ha una sola funzione,
e precisamente:
<P>
<BLOCKQUOTE><CODE>
<PRE>
GtkWidget* gtk_dialog_new (void);
</PRE>
</CODE></BLOCKQUOTE>
<P>Per cui, per creare una nuova finestra di dialogo, uate:
<P>
<BLOCKQUOTE><CODE>
<PRE>
GtkWidget *window;
window = gtk_dialog_new ();
</PRE>
</CODE></BLOCKQUOTE>
<P>Questa funzione crea una finestra di dialogo, dopodich&eacute; sta a voi 
utilizzarla. Potete mettere un bottone nella action_area facendo
qualcosa del tipo:
<P>
<BLOCKQUOTE><CODE>
<PRE>
button = ...
gtk_box_pack_start (GTK_BOX (GTK_DIALOG (window)->action_area), button,
                    TRUE, TRUE, 0);
gtk_widget_show (button);
</PRE>
</CODE></BLOCKQUOTE>
<P>Potreste anche aggiungere, ad esempio, un'etichetta all'area della vbox,
con qualcosa di questo genere:
<P>
<BLOCKQUOTE><CODE>
<PRE>
label = gtk_label_new ("Dialogs are groovy");
gtk_box_pack_start (GTK_BOX (GTK_DIALOG (window)->vbox), label, TRUE,
                    TRUE, 0);
gtk_widget_show (label);
</PRE>
</CODE></BLOCKQUOTE>
<P>Per provare a usare una finestra di dialogo, potreste provare a mettere
due bottoni nella action_area, per esempio un bottone ``Cancella'' ed un
bottone ``OK'' e un'etichetta nella vbox che chieda qualcosa all'utente o
segnali un errore. Poi potreste collegare un diverso segnale a ciascun
bottone ed eseguire l'operazione che l'utente che viene scelta dall'utente.
<P>
<H2><A NAME="ss7.5">7.5 Le Pixmap</A>
</H2>

<P>
<P>Le Pixmap sono strutture dati che contengono immagini. Queste immagini
possono poi essere utilizzate in varie occasioni, per esempio come 
icone sul desktop X-Window o come cusori. Una bitmap &egrave; una pixmap a due
colori.
<P>Per usare una pixmap in GTK, dobbiamo in primo luogo creare una struttura
GdkPixmap utilizzando le routine disponibili nello strato GDK. Una Pixmap
pu&ograve; essere creata a partire da dati presenti in memoria o letti da un file.
Vedremo ora una ad una le chiamate utilizzate per creare una pixmap.
<P>
<BLOCKQUOTE><CODE>
<PRE>
GdkPixmap *gdk_bitmap_create_from_data( GdkWindow *window,
                                        gchar     *data,
                                        gint      width,
                                        gint      height );
</PRE>
</CODE></BLOCKQUOTE>
<P>Si usa questa routine per creare una pixmap ad un solo piano (2 colori) da
dati disponibili in memoria. Ogni bit nei dati indica lo stato acceso o
spento di un pixel. L'altezza (height) e la larghezza (width) sono espresse
in pixel. GdkWindow &egrave; un puntatore alla finestra corrente, dal momento che
le risorse di una pixmap hanno significato solo nel contesto dello schermo 
in cui deve essere mostrata.
<P>
<BLOCKQUOTE><CODE>
<PRE>
GdkPixmap* gdk_pixmap_create_from_data( GdkWindow  *window,
                                        gchar      *data,
                                        gint        width,
                                        gint        height,
                                        gint        depth,
                                        GdkColor   *fg,
                                        GdkColor   *bg );
</PRE>
</CODE></BLOCKQUOTE>
<P>Questa &egrave; usata per creare una pixmap con la profondit&agrave; data (depth, ossia 
numero di colori) usando i dati specificati. fg e bg indicano i colori da
usare per il primo piano e per lo sfondo.
<P>
<BLOCKQUOTE><CODE>
<PRE>
GdkPixmap* gdk_pixmap_create_from_xpm( GdkWindow  *window,
                                       GdkBitmap **mask,
                                       GdkColor   *transparent_color,
                                       const gchar *filename );
</PRE>
</CODE></BLOCKQUOTE>
<P>Il formato XPM &egrave; una rappresentazione di pixmap leggibile per X Window. E' una
rappresentazione molto diffusa, e sono disponibili parecchi programmi per creare
immagini in questo formato. Il file specificato da ``filename'' deve contenere
un'immagine in questo formato, che viene caricato nella struttura pixmap.
La maschera (mask) specifica quali pixel della pixmap devono essere opachi.
Tutti gli altri pixel sono colorati usando il colore specificato da
transparent_color. Pi&ugrave; sotto mostreremo un esempio di uso di questa funzione.
<P>
<BLOCKQUOTE><CODE>
<PRE>
GdkPixmap* gdk_pixmap_create_from_xpm_d (GdkWindow  *window,
                                         GdkBitmap **mask,
                                         GdkColor   *transparent_color,
                                         gchar     **data);
</PRE>
</CODE></BLOCKQUOTE>
<P>Si possono incorporare piccole immagini all'interno di un programma sotto
forma di dati in formato XPM. In questo modo, invece di leggerli da un file,
si possono usare questi dati per creare una pixmap. Un esempio di questo tipo
di dati &egrave;
<P>
<BLOCKQUOTE><CODE>
<PRE>
/* XPM */
static const char * xpm_data[] = {
"16 16 3 1",
"       c None",
".      c #000000000000",
"X      c #FFFFFFFFFFFF",
"                ",
"   ......       ",
"   .XXX.X.      ",
"   .XXX.XX.     ",
"   .XXX.XXX.    ",
"   .XXX.....    ",
"   .XXXXXXX.    ",
"   .XXXXXXX.    ",
"   .XXXXXXX.    ",
"   .XXXXXXX.    ",
"   .XXXXXXX.    ",
"   .XXXXXXX.    ",
"   .XXXXXXX.    ",
"   .........    ",
"                ",
"                "};
</PRE>
</CODE></BLOCKQUOTE>
<P>
<BLOCKQUOTE><CODE>
<PRE>
void gdk_pixmap_destroy( GdkPixmap  *pixmap );
</PRE>
</CODE></BLOCKQUOTE>
<P>Quando abbiamo finito di usare una pixmap e pensiamo di non doverla riutilizzare
presto, &egrave; una buona idea liberare queste risorse usando la funzione 
dk_pixmap_destroy. Le pixmap devono essere considerate una risorsa preziosa.
<P>Quando abbiamo creato una pixmap, possiamo mostrarla come un widget GTK.
E' necessario creare un widget pixmap che contenga una pixmap GDK. Questa
operazione viene compiuta usando
<P>
<BLOCKQUOTE><CODE>
<PRE>
GtkWidget* gtk_pixmap_new( GdkPixmap  *pixmap,
                           GdkBitmap  *mask );
</PRE>
</CODE></BLOCKQUOTE>
<P>Le altre chiamate per i widget pixmap sono
<P>
<BLOCKQUOTE><CODE>
<PRE>
guint gtk_pixmap_get_type( void );
void  gtk_pixmap_set( GtkPixmap  *pixmap,
                      GdkPixmap  *val,
                      GdkBitmap  *mask);
void  gtk_pixmap_get( GtkPixmap  *pixmap,
                      GdkPixmap **val,
                      GdkBitmap **mask);
</PRE>
</CODE></BLOCKQUOTE>
<P>La funzione gtk_pixmap_set viene usata per cambiare la pixmap che viene
gestita correntemente dal widget.
gtk_pixmap_set is used to change the pixmap that the widget is currently
managing.  ``val'' &egrave; la pixmap che &egrave; stata creata usando il GDK.
Segue un esempio di uso di una pixmap in un bottone.
<P>
<BLOCKQUOTE><CODE>
<PRE>
/* pixmap.c */
#include &lt;gtk/gtk.h>


/* dat XPM dell'icona Apri File */
static const char * xpm_data[] = {
"16 16 3 1",
"       c None",
".      c #000000000000",
"X      c #FFFFFFFFFFFF",
"                ",
"   ......       ",
"   .XXX.X.      ",
"   .XXX.XX.     ",
"   .XXX.XXX.    ",
"   .XXX.....    ",
"   .XXXXXXX.    ",
"   .XXXXXXX.    ",
"   .XXXXXXX.    ",
"   .XXXXXXX.    ",
"   .XXXXXXX.    ",
"   .XXXXXXX.    ",
"   .XXXXXXX.    ",
"   .........    ",
"                ",
"                "};


/* quando invocata (con il segnale delete_event), termina l'applicazione. */
void close_application( GtkWidget *widget, gpointer data ) {
    gtk_main_quit();
}

/* invocata se il bottone &egrave; clickato. Stampa semplicemente un messaggio */
void button_clicked( GtkWidget *widget, gpointer data ) {
    printf( "button clicked\n" );
}

int main( int argc, char *argv[] )
{
    /* i widget sono memorizzati nel tipo GtkWidget */
    GtkWidget *window, *pixmapwid, *button;
    GdkPixmap *pixmap;
    GdkBitmap *mask;
    GtkStyle *style;
    
    /* crea la finestra principale, e collega il segnale delete_event
       alla terminazione dell'applicazione */
    gtk_init( &amp;argc, &amp;argv );
    window = gtk_window_new( GTK_WINDOW_TOPLEVEL );
    gtk_signal_connect( GTK_OBJECT (window), "delete_event",
                        GTK_SIGNAL_FUNC (close_application), NULL );
    gtk_container_border_width( GTK_CONTAINER (window), 10 );
    gtk_widget_show( window );

    /* la pixmap proviene da gdk */
    style = gtk_widget_get_style( window );
    pixmap = gdk_pixmap_create_from_xpm_d( window->window,  &amp;mask,
                                           &amp;style->bg[GTK_STATE_NORMAL],
                                           (gchar **)xpm_data );

    /* un widget pixmap per contenere la pixmap */
    pixmapwid = gtk_pixmap_new( pixmap, mask );
    gtk_widget_show( pixmapwid );

    /* un bottone per contenere il widget pixmap */
    button = gtk_button_new();
    gtk_container_add( GTK_CONTAINER(button), pixmapwid );
    gtk_container_add( GTK_CONTAINER(window), button );
    gtk_widget_show( button );

    gtk_signal_connect( GTK_OBJECT(button), "clicked",
                        GTK_SIGNAL_FUNC(button_clicked), NULL );

    /* mostra la finestra */
    gtk_main ();
          
    return 0;
}
</PRE>
</CODE></BLOCKQUOTE>
<P>
<P>Per caricare una pixmap da un file XPM chiamato icon0.xpm che si trova
nella direttorio corrente, avremmo creato la pixmap in questo modo:
<P>
<BLOCKQUOTE><CODE>
<PRE>
    /* carica una pixmap da un file */
    pixmap = gdk_pixmap_create_from_xpm( window->window, &amp;mask,
                                         &amp;style->bg[GTK_STATE_NORMAL],
                                         "./icon0.xpm" );
    pixmapwid = gtk_pixmap_new( pixmap, mask );
    gtk_widget_show( pixmapwid );
    gtk_container_add( GTK_CONTAINER(window), pixmapwid );
</PRE>
</CODE></BLOCKQUOTE>
<P>
<P>Usare le Sagome
<P>Uno degli svantaggi di usare le pixmap &egrave; costituito dal fatto che l'oggetto
mostrato &egrave; sempre rettangolare, a prescindere dall'immagine. Ci piacerebbe
invece poter crare dei desktop e delle immagini con forme pi&ugrave; naturali. Per
esempio, per l'interfaccia di un gioco, potremmo volere avere dei pulsanti
circolari. Il modo per ottenere questo effetto &egrave; di usare delle finestre
sagomate.
<P>Una finestra sagomata &egrave; semplicemente una pixmap in cui i pixel dello
sfondo sono trasparenti. In questo modo, se l'immagine di sfondo &egrave; 
multicolore, possiamo evitare di sovrascriverla con un bordo rettangolare
attorno all'icona. Il prossimo esempio mostra una carriola sul desktop.
<P>
<BLOCKQUOTE><CODE>
<PRE>
/* wheelbarrow.c */
#include &lt;gtk/gtk.h>

/* XPM */
static char * WheelbarrowFull_xpm[] = {
"48 48 64 1",
"       c None",
".      c #DF7DCF3CC71B",
"X      c #965875D669A6",
"o      c #71C671C671C6",
"O      c #A699A289A699",
"+      c #965892489658",
"@      c #8E38410330C2",
"#      c #D75C7DF769A6",
"$      c #F7DECF3CC71B",
"%      c #96588A288E38",
"&amp;      c #A69992489E79",
"*      c #8E3886178E38",
"=      c #104008200820",
"-      c #596510401040",
";      c #C71B30C230C2",
":      c #C71B9A699658",
">      c #618561856185",
",      c #20811C712081",
"&lt;      c #104000000000",
"1      c #861720812081",
"2      c #DF7D4D344103",
"3      c #79E769A671C6",
"4      c #861782078617",
"5      c #41033CF34103",
"6      c #000000000000",
"7      c #49241C711040",
"8      c #492445144924",
"9      c #082008200820",
"0      c #69A618611861",
"q      c #B6DA71C65144",
"w      c #410330C238E3",
"e      c #CF3CBAEAB6DA",
"r      c #71C6451430C2",
"t      c #EFBEDB6CD75C",
"y      c #28A208200820",
"u      c #186110401040",
"i      c #596528A21861",
"p      c #71C661855965",
"a      c #A69996589658",
"s      c #30C228A230C2",
"d      c #BEFBA289AEBA",
"f      c #596545145144",
"g      c #30C230C230C2",
"h      c #8E3882078617",
"j      c #208118612081",
"k      c #38E30C300820",
"l      c #30C2208128A2",
"z      c #38E328A238E3",
"x      c #514438E34924",
"c      c #618555555965",
"v      c #30C2208130C2",
"b      c #38E328A230C2",
"n      c #28A228A228A2",
"m      c #41032CB228A2",
"M      c #104010401040",
"N      c #492438E34103",
"B      c #28A2208128A2",
"V      c #A699596538E3",
"C      c #30C21C711040",
"Z      c #30C218611040",
"A      c #965865955965",
"S      c #618534D32081",
"D      c #38E31C711040",
"F      c #082000000820",
"                                                ",
"          .XoO                                  ",
"         +@#$%o&amp;                                ",
"         *=-;#::o+                              ",
"           >,&lt;12#:34                            ",
"             45671#:X3                          ",
"               +89&lt;02qwo                        ",
"e*                >,67;ro                       ",
"ty>                 459@>+&amp;&amp;                    ",
"$2u+                  >&lt;ipas8*                  ",
"%$;=*                *3:.Xa.dfg>                ",
"Oh$;ya             *3d.a8j,Xe.d3g8+             ",
" Oh$;ka          *3d$a8lz,,xxc:.e3g54           ",
"  Oh$;kO       *pd$%svbzz,sxxxxfX..&amp;wn>         ",
"   Oh$@mO    *3dthwlsslszjzxxxxxxx3:td8M4       ",
"    Oh$@g&amp; *3d$XNlvvvlllm,mNwxxxxxxxfa.:,B*     ",
"     Oh$@,Od.czlllllzlmmqV@V#V@fxxxxxxxf:%j5&amp;   ",
"      Oh$1hd5lllslllCCZrV#r#:#2AxxxxxxxxxcdwM*  ",
"       OXq6c.%8vvvllZZiqqApA:mq:Xxcpcxxxxxfdc9* ",
"        2r&lt;6gde3bllZZrVi7S@SV77A::qApxxxxxxfdcM ",
"        :,q-6MN.dfmZZrrSS:#riirDSAX@Af5xxxxxfevo",
"         +A26jguXtAZZZC7iDiCCrVVii7Cmmmxxxxxx%3g",
"          *#16jszN..3DZZZZrCVSA2rZrV7Dmmwxxxx&amp;en",
"           p2yFvzssXe:fCZZCiiD7iiZDiDSSZwwxx8e*>",
"           OA1&lt;jzxwwc:$d%NDZZZZCCCZCCZZCmxxfd.B ",
"            3206Bwxxszx%et.eaAp77m77mmmf3&amp;eeeg* ",
"             @26MvzxNzvlbwfpdettttttttttt.c,n&amp;  ",
"             *;16=lsNwwNwgsvslbwwvccc3pcfu&lt;o    ",
"              p;&lt;69BvwwsszslllbBlllllllu&lt;5+     ",
"              OS0y6FBlvvvzvzss,u=Blllj=54       ",
"               c1-699Blvlllllu7k96MMMg4         ",
"               *10y8n6FjvllllB&lt;166668           ",
"                S-kg+>666&lt;M&lt;996-y6n&lt;8*          ",
"                p71=4 m69996kD8Z-66698&amp;&amp;        ",
"                &amp;i0ycm6n4 ogk17,0&lt;6666g         ",
"                 N-k-&lt;>     >=01-kuu666>        ",
"                 ,6ky&amp;      &amp;46-10ul,66,        ",
"                 Ou0&lt;>       o66y&lt;ulw&lt;66&amp;       ",
"                  *kk5       >66By7=xu664       ",
"                   &lt;&lt;M4      466lj&lt;Mxu66o       ",
"                   *>>       +66uv,zN666*       ",
"                              566,xxj669        ",
"                              4666FF666>        ",
"                               >966666M         ",
"                                oM6668+         ",
"                                  *4            ",
"                                                ",
"                                                "};


/* quando invocata (con il segnale delete_event), termina l'applicazione. */
void close_application( GtkWidget *widget, gpointer data ) {
    gtk_main_quit();
}

int main (int argc, char *argv[])
{
    /* il tipo di dato per i widget &egrave; GtkWidget */
    GtkWidget *window, *pixmap, *fixed;
    GdkPixmap *gdk_pixmap;
    GdkBitmap *mask;
    GtkStyle *style;
    GdkGC *gc;
    
    /* crea la finestra principale e collega il segnale delete_event per
       terminare l'applicazione. Notare che non mettiamo un titolo 
       alla finestra. */
    gtk_init (&amp;argc, &amp;argv);
    window = gtk_window_new( GTK_WINDOW_POPUP );
    gtk_signal_connect (GTK_OBJECT (window), "delete_event",
                        GTK_SIGNAL_FUNC (close_application), NULL);
    gtk_widget_show (window);

    /* ora occupiamoci della pixmap e del widget pixmap */
    style = gtk_widget_get_default_style();
    gc = style->black_gc;
    gdk_pixmap = gdk_pixmap_create_from_xpm_d( window->window, &amp;mask,
                                             &amp;style->bg[GTK_STATE_NORMAL],
                                             WheelbarrowFull_xpm );
    pixmap = gtk_pixmap_new( gdk_pixmap, mask );
    gtk_widget_show( pixmap );

    /* Per mostrare la pixmap, usiamo un widget "fixed" in cui metterla */
    fixed = gtk_fixed_new();
    gtk_widget_set_usize( fixed, 200, 200 );
    gtk_fixed_put( GTK_FIXED(fixed), pixmap, 0, 0 );
    gtk_container_add( GTK_CONTAINER(window), fixed );
    gtk_widget_show( fixed );

    /* Questa maschera tutto tranne l'immagine stessa */
    gtk_widget_shape_combine_mask( window, mask, 0, 0 );
    
    /* mostra la finestra */
    gtk_widget_set_uposition( window, 20, 400 );
    gtk_widget_show( window );
    gtk_main ();
          
    return 0;
}
</PRE>
</CODE></BLOCKQUOTE>
<P>Per rendere sensibile l'immagine della carriola, potremmo collegare
il segnale di pressione del bottone in modo che venga compiuta una certa
azione. Le prossime linee renderebbero l'immagine sensibile alla pressione
di un bottone del mouse che fa s&igrave; che l'applicazione termini.
<P>
<BLOCKQUOTE><CODE>
<PRE>
gtk_widget_set_events( window,
                       gtk_widget_get_events( window ) |
                       GDK_BUTTON_PRESS_MASK );

gtk_signal_connect( GTK_OBJECT(window), "button_press_event",
                    GTK_SIGNAL_FUNC(close_application), NULL );
</PRE>
</CODE></BLOCKQUOTE>
<P>
<H2><A NAME="ss7.6">7.6 Righelli</A>
</H2>

<P>I widget righello vengono usati per indicare la posizione del pontatore del
mouse in una certa finestra. Una finestra pu&ograve; cio&eacute; avere un
righello orizzontale che si estende per tutta la sua ampiezza e un righello verticale
che ne comprende l'altezza. Un piccolo triangolo sui rghelli indica la posizione
esatta del puntatore relativamente ai righelli.
<P>I righelli devono essere in primo luogo creati. I righlli orizzontali e verticali vengono
creati usando
<P>
<BLOCKQUOTE><CODE>
<PRE>
GtkWidget *gtk_hruler_new(void);    /* horizontal ruler */
GtkWidget *gtk_vruler_new(void);    /* vertical ruler   */
</PRE>
</CODE></BLOCKQUOTE>
<P>Una volta che che si &egrave; creato il righello, si pu&ograve; l'unit&agrave; di
misura. Le unit&agrave; di misura possono essere GTK_PIXELS,
GTK_INCHES oppure GTK_CENTIMETERS. Ci&ograve; viene stabilito usando
<P>
<BLOCKQUOTE><CODE>
<PRE>
void gtk_ruler_set_metric( GtkRuler        *ruler,
                           GtkMetricType   metric );
</PRE>
</CODE></BLOCKQUOTE>
<P>La misura predefinita &egrave;  GTK_PIXELS.
<P>
<BLOCKQUOTE><CODE>
<PRE>
gtk_ruler_set_metric( GTK_RULER(ruler), GTK_PIXELS );
</PRE>
</CODE></BLOCKQUOTE>
<P>Altre caratteritiche importanti di un righello sono il modo in cui vengono segnate
le tacche delle unit&agrave; di misura e dove viene posto inizialmente l'indicatore
di posizione. Questi vengono stabiliti usando
<P>
<BLOCKQUOTE><CODE>
<PRE>
void  gtk_ruler_set_range  (GtkRuler       *ruler,
                            gfloat          lower,
                            gfloat          upper,
                            gfloat          position,
                            gfloat          max_size);
</PRE>
</CODE></BLOCKQUOTE>
<P>Gli argomenti lower e upper definiscono l'estensione del righello, e
max_size rappresenta il numero massimo che verr&agrave; mostrato.
Position definisce l posizione iniziale dell'indicatore del puntatore 
all'interno del righello.
<P>Quindi, un righello che pu&ograve; stare su una finestra di 800 pixel sar&agrave;:
<P>
<BLOCKQUOTE><CODE>
<PRE>
gtk_ruler_set_range( GTK_RULER(vruler), 0, 800, 0, 800);
</PRE>
</CODE></BLOCKQUOTE>
<P>Sul righello saranno presenti dei segni da 0 a 800, con un numero ogni 100 pixel.
Se avessimo invece voluto che il righello fosse andato da 7 a 16, avremmo scritto:
<P>
<BLOCKQUOTE><CODE>
<PRE>
gtk_ruler_set_range( GTK_RULER(vruler), 7, 16, 0, 20);
</PRE>
</CODE></BLOCKQUOTE>
<P>L'indicatore sul righello &egrave; un piccolo segno triangolare che indica
la posizione del puntatore rispetto al righello. Se il righello viene usato
per seguire il movimento del mouse, il segnale di motion_notify_event
dovrebbe venir connesso al metodo motion_notify_event del righello.
Per seguire tutti i movimenti del mouse all'interno dell'area di una finestra,
useremmo:
<P>
<BLOCKQUOTE><CODE>
<PRE>
#define EVENT_METHOD(i, x) GTK_WIDGET_CLASS(GTK_OBJECT(i)->klass)->x

gtk_signal_connect_object( GTK_OBJECT(area), "motion_notify_event",
         (GtkSignalFunc)EVENT_METHOD(ruler, motion_notify_event),
         GTK_OBJECT(ruler) );
</PRE>
</CODE></BLOCKQUOTE>
<P>L'esempio seguente crea un'area di disegno con un reghello orizzontale nella
parte superiore e un righello verticale nella parte sinistra. Le dimensioni
di questa area di disegno sono di 600 e 400 pixel risettivamente per la larghezza
e per l'altezza. Il righello orizzontale va da 7 a 13 con una tacca ogni 100 pixel,
mentre quello verticale va da 0 a 400, ancora con una tacca ogni 100 pixel.
La sistemazione dell'area di disegno e dei righelli viene fatta usando una tabella.
<P>
<BLOCKQUOTE><CODE>
<PRE>
/* rulers.c */

#include &lt;gtk/gtk.h>

#define EVENT_METHOD(i, x) GTK_WIDGET_CLASS(GTK_OBJECT(i)->klass)->x

#define XSIZE  600
#define YSIZE  400

/* il controllo raggiunge questa routine quando si preme il bottone close 
 */
void close_application( GtkWidget *widget, gpointer data ) {
    gtk_main_quit();
}

/* la routine principale
 */
int main( int argc, char *argv[] ) {
    GtkWidget *window, *table, *area, *hrule, *vrule;

    /* inizializziamo gtk e creiamo la finestra principale */
    gtk_init( &amp;argc, &amp;argv );

    window = gtk_window_new( GTK_WINDOW_TOPLEVEL );
    gtk_signal_connect (GTK_OBJECT (window), "delete_event",
            GTK_SIGNAL_FUNC( close_application ), NULL);
    gtk_container_border_width (GTK_CONTAINER (window), 10);

    /* creiamo una tabella in cui mettere righelli e area di disegno */
    table = gtk_table_new( 3, 2, FALSE );
    gtk_container_add( GTK_CONTAINER(window), table );

    area = gtk_drawing_area_new();
    gtk_drawing_area_size( (GtkDrawingArea *)area, XSIZE, YSIZE );
    gtk_table_attach( GTK_TABLE(table), area, 1, 2, 1, 2,
                      GTK_EXPAND|GTK_FILL, GTK_FILL, 0, 0 );
    gtk_widget_set_events( area, GDK_POINTER_MOTION_MASK | GDK_POINTER_MOTION_HINT_MASK );

    /* Il righello orizzontale va nella parte superiore. Quando il mouse si muove
     * nell'area di disegno, si passa un motion_notify_event al gestore appropriato
     * per il righello. */

    hrule = gtk_hruler_new();
    gtk_ruler_set_metric( GTK_RULER(hrule), GTK_PIXELS );
    gtk_ruler_set_range( GTK_RULER(hrule), 7, 13, 0, 20 );
    gtk_signal_connect_object( GTK_OBJECT(area), "motion_notify_event",
                               (GtkSignalFunc)EVENT_METHOD(hrule, motion_notify_event),
                               GTK_OBJECT(hrule) );
    /*  GTK_WIDGET_CLASS(GTK_OBJECT(hrule)->klass)->motion_notify_event, */
    gtk_table_attach( GTK_TABLE(table), hrule, 1, 2, 0, 1,
                      GTK_EXPAND|GTK_SHRINK|GTK_FILL, GTK_FILL, 0, 0 );
    
    /* Il righello verticale va nella parte sinistra.  Quando il mouse si muove
     * nell'area di disegno, si passa un motion_notify_event al gestore appropriato
     * per il righello. */

    vrule = gtk_vruler_new();
    gtk_ruler_set_metric( GTK_RULER(vrule), GTK_PIXELS );
    gtk_ruler_set_range( GTK_RULER(vrule), 0, YSIZE, 10, YSIZE );
    gtk_signal_connect_object( GTK_OBJECT(area), "motion_notify_event",
                               (GtkSignalFunc)
                                  GTK_WIDGET_CLASS(GTK_OBJECT(vrule)->klass)-motion_notify_event,
                               GTK_OBJECT(vrule) );
    gtk_table_attach( GTK_TABLE(table), vrule, 0, 1, 1, 2,
                      GTK_FILL, GTK_EXPAND|GTK_SHRINK|GTK_FILL, 0, 0 );

    /* ora mostriamo tutto quanto */
    gtk_widget_show( area );
    gtk_widget_show( hrule );
    gtk_widget_show( vrule );
    gtk_widget_show( table );
    gtk_widget_show( window );
    gtk_main();

    return 0;
}
</PRE>
</CODE></BLOCKQUOTE>
<P>
<H2><A NAME="ss7.7">7.7 Barre di Stato (Statusbar)</A>
</H2>

<P>Le barre di stato sono dei semplici widget usati per mostrare messaggi di test.
Hanno la caratteristica di mantenere uno stack dei messggi che vi vengono
mostrati, cosicche&eacute; rimuovendo il messaggio corrente fa s&igrave; che
torni ad essere mostrato il messaggio precedente..
<P>Per permettere a parti diverse di una stessa applicazione di usare la stessa barra di
stato per mostrare messaggi, questo widget emette degli 'Identificatori di Contesto'
che vengono usati per identificare i diversi 'utenti'. Quello che viene mostrato
&egrave; sempre il messaggio che si trova in cima allo stack, a prescindere in
quale contesto si trovi. I messaggi vengono immagazzinati secondo l'ordine
LIFO, e non secondo l'ordine stabilito dal contesto.
<P>Una barra di stato viene creata con una chiamata a:
<BLOCKQUOTE><CODE>
<PRE>
GtkWidget* gtk_statusbar_new (void);
</PRE>
</CODE></BLOCKQUOTE>
<P>Per richiedere un nuovo identificatore di contesto, si usa una chiamata alla seguente
funzione con una breve descrizione testuale:
<BLOCKQUOTE><CODE>
<PRE>
guint gtk_statusbar_get_context_id (GtkStatusbar *statusbar,
                                    const gchar  *context_description);
</PRE>
</CODE></BLOCKQUOTE>
<P>Le seguenti sono tre funzioni che possono operare sulle barre di stato:
<BLOCKQUOTE><CODE>
<PRE>
guint       gtk_statusbar_push           (GtkStatusbar *statusbar,
                                         guint          context_id,
                                         gchar         *text);

void       gtk_statusbar_pop            (GtkStatusbar *statusbar)
                                         guint         context_id);
void       gtk_statusbar_remove         (GtkStatusbar *statusbar,
                                         guint         context_id,
                                         guint         message_id); 
</PRE>
</CODE></BLOCKQUOTE>
<P>La prima, gtk_statusbar_push, viene usata per aggiungere un nuovo messaggio
alla barra di stato. Questa restituisce un identificatore di messaggio, che pu&ograve;
essere passato successivamente alla funzione gtk_statusbar_remove per rimuovere
dallo stack il messggio con identificatore di messaggio e di contesto dati.
<P>La funzione gtk_statusbar_pop rimuove il messaggio che si trova in cima allo stack
avente un dato identificatore di contesto.
<P>Nel seguente esempio si crea una barra di stato e due bottoni, uno per mettere
elementi sulla barra di stato e l'altro per riuovere l'ultimo elemento..
<P>
<BLOCKQUOTE><CODE>
<PRE>
/* statusbar.c */

#include &lt;gtk/gtk.h>
#include &lt;glib.h>

GtkWidget *status_bar;
 
void push_item (GtkWidget *widget, gpointer data)
{
  static int count = 1;
  char buff[20];

  g_snprintf(buff, 20, "Item %d", count++);
  gtk_statusbar_push( GTK_STATUSBAR(status_bar), (guint) &amp;data, buff);

  return;
}

void pop_item (GtkWidget *widget, gpointer data)
{
  gtk_statusbar_pop( GTK_STATUSBAR(status_bar), (guint) &amp;data );
  return;
}

int main (int argc, char *argv[])
{

    GtkWidget *window;
    GtkWidget *vbox;
    GtkWidget *button;

    int context_id;

    gtk_init (&amp;argc, &amp;argv);

    /* creazione di una nuova finestra */
    window = gtk_window_new(GTK_WINDOW_TOPLEVEL);
    gtk_widget_set_usize( GTK_WIDGET (window), 200, 100);
    gtk_window_set_title(GTK_WINDOW (window), "GTK Statusbar Example");
    gtk_signal_connect(GTK_OBJECT (window), "delete_event",
                       (GtkSignalFunc) gtk_exit, NULL);
 
    vbox = gtk_vbox_new(FALSE, 1);
    gtk_container_add(GTK_CONTAINER(window), vbox);
    gtk_widget_show(vbox);
          
    status_bar = gtk_statusbar_new();      
    gtk_box_pack_start (GTK_BOX (vbox), status_bar, TRUE, TRUE, 0);
    gtk_widget_show (status_bar);

    context_id = gtk_statusbar_get_context_id( GTK_STATUSBAR(status_bar), "Statusbar example");

    button = gtk_button_new_with_label("push item");
    gtk_signal_connect(GTK_OBJECT(button), "clicked",
        GTK_SIGNAL_FUNC (push_item), &amp;context_id);
    gtk_box_pack_start(GTK_BOX(vbox), button, TRUE, TRUE, 2);
    gtk_widget_show(button);              

    button = gtk_button_new_with_label("pop last item");
    gtk_signal_connect(GTK_OBJECT(button), "clicked",
        GTK_SIGNAL_FUNC (pop_item), &amp;context_id);
    gtk_box_pack_start(GTK_BOX(vbox), button, TRUE, TRUE, 2);
    gtk_widget_show(button);              

    /* la finestra va sempre mostrata come ultimo passo, in modo che venga
     * sullo schermo tutta in una volta. */
    gtk_widget_show(window);

    gtk_main ();

    return 0;
}
</PRE>
</CODE></BLOCKQUOTE>
<P>
<H2><A NAME="ss7.8">7.8 Inserimento di testo</A>
</H2>

<P>Questo widget permette diinserire e mostrare del testo in una casella contenente una
sola linea. Il testo pu&ograve; essere assegnato con chiamate di funzione che
permettono a nuovo testo di sostituire, seguire o precedere il contenuto corrente
del widget di inserimento testo.
<P>Per la creazione di un inserimento di testo, sono disponibili due funzioni:
<BLOCKQUOTE><CODE>
<PRE>
GtkWidget* gtk_entry_new (void);

GtkWidget* gtk_entry_new_with_max_length (guint16 max);
</PRE>
</CODE></BLOCKQUOTE>
<P>La prima crea solamente un inserimento di testo, mentre la seconda lo crea
imponendo un limite alla lunghezza del testo inseribile..
<P>Per cambiaere il testo che si trova correntemente nel widget, sono disponibili diverse
funzioni.
<BLOCKQUOTE><CODE>
<PRE>
void gtk_entry_set_text       (GtkEntry    *entry,
                               const gchar *text);
void gtk_entry_append_text    (GtkEntry    *entry,
                               const gchar *text);
void gtk_entry_prepend_text   (GtkEntry    *entry,
                               const gchar *text);
</PRE>
</CODE></BLOCKQUOTE>
<P>La funzione gtk_entry_set_text assegna il contenuto del widget di inserimento,
sostituendo il contenuto corrente. Le funzioni gtk_entry_append_text e gtk_entry_prepend_text
permettono di antemporre o posporre un testo al testo corrente..
<P>La prossima funzione permette di stabilire il punto di inserimento.
<BLOCKQUOTE><CODE>
<PRE>
void gtk_entry_set_position   (GtkEntry *entry,
                               gint     position);
</PRE>
</CODE></BLOCKQUOTE>
<P>Usando la seguente funzione, &egrave; possibile estrarre il contenuto di un widget di inserimento.
Ci&ograve; pu&ograve; essere utile nelle funzioni di ritorno come descritto pi&ugrave; sotto.
<BLOCKQUOTE><CODE>
<PRE>
gchar* gtk_entry_get_text (GtkEntry *entry);
</PRE>
</CODE></BLOCKQUOTE>
<P>Se non si vuole che qualcuno possa cambiare il contenuto di una entry sovrascrivendola,
ne possiamo cambiare lo stato di "editabilit&agrave;"..
<BLOCKQUOTE><CODE>
<PRE>
void gtk_entry_set_editable (GtkEntry *entry,
                             gboolean editable);
</PRE>
</CODE></BLOCKQUOTE>
<P>Questa funzine ci permette di far passare un widget di inserimento dallo sato di editabile a
quello di non editabile passando con l'argomento editable i valori TRUE o FALSE.
<P>Se stiamo usando l'entry in un punto in cui non vogliamo che il testo sia visibile, per
esempio quando si digita una password, possiamo usare la seguente funzione, che
accetta un parametro booleano..
<BLOCKQUOTE><CODE>
<PRE>
void gtk_entry_set_visibility (GtkEntry *entry,
                               gboolean visible);
</PRE>
</CODE></BLOCKQUOTE>
<P>Si pu&ograve; stabilire che una parte del testo  risulti selezionata usado la seguente funzione.
Si user&agrave; di solito questa possibilit&agrave; dopo aver inserito nel widget un
qualche valore predefinito, in modo che per l'utente sia semplice sostituirlo. 
<P>
<BLOCKQUOTE><CODE>
<PRE>
void gtk_entry_select_region (GtkEntry *entry,
                              gint     start,
                              gint     end);
</PRE>
</CODE></BLOCKQUOTE>
<P>Se vogliamo accorgerci del momento in cui l'utente ha inserito del testo, possiamo connettere
il segnale <CODE>activate</CODE> o <CODE>changed</CODE>. <CODE>activate</CODE> viene reso attivo quando
l'utente preme il tasto Enter mentre si trova nel widget. <CODE>changed</CODE> viene invece emesso ogni volta che
il testo cambia, per esempio ogni volta che viene inserito o rimosso un carattere.
<P>Il seguente codice mostra un esempio di utilizzo del widget di inserimento.
.
<BLOCKQUOTE><CODE>
<PRE>
/* entry.c */

#include &lt;gtk/gtk.h>

void enter_callback(GtkWidget *widget, GtkWidget *entry)
{
  gchar *entry_text;
  entry_text = gtk_entry_get_text(GTK_ENTRY(entry));
  printf("Entry contents: %s\n", entry_text);
}

void entry_toggle_editable (GtkWidget *checkbutton,
                                   GtkWidget *entry)
{
  gtk_entry_set_editable(GTK_ENTRY(entry),
                         GTK_TOGGLE_BUTTON(checkbutton)->active);
}

void entry_toggle_visibility (GtkWidget *checkbutton,
                                   GtkWidget *entry)
{
  gtk_entry_set_visibility(GTK_ENTRY(entry),
                         GTK_TOGGLE_BUTTON(checkbutton)->active);
}

int main (int argc, char *argv[])
{

    GtkWidget *window;
    GtkWidget *vbox, *hbox;
    GtkWidget *entry;
    GtkWidget *button;
    GtkWidget *check;

    gtk_init (&amp;argc, &amp;argv);

    /* creiamo una nuova finestra */
    window = gtk_window_new(GTK_WINDOW_TOPLEVEL);
    gtk_widget_set_usize( GTK_WIDGET (window), 200, 100);
    gtk_window_set_title(GTK_WINDOW (window), "GTK Entry");
    gtk_signal_connect(GTK_OBJECT (window), "delete_event",
                       (GtkSignalFunc) gtk_exit, NULL);

    vbox = gtk_vbox_new (FALSE, 0);
    gtk_container_add (GTK_CONTAINER (window), vbox);
    gtk_widget_show (vbox);

    entry = gtk_entry_new_with_max_length (50);
    gtk_signal_connect(GTK_OBJECT(entry), "activate",
                       GTK_SIGNAL_FUNC(enter_callback),
                       entry);
    gtk_entry_set_text (GTK_ENTRY (entry), "hello");
    gtk_entry_append_text (GTK_ENTRY (entry), " world");
    gtk_entry_select_region (GTK_ENTRY (entry),
                             0, GTK_ENTRY(entry)->text_length);
    gtk_box_pack_start (GTK_BOX (vbox), entry, TRUE, TRUE, 0);
    gtk_widget_show (entry);

    hbox = gtk_hbox_new (FALSE, 0);
    gtk_container_add (GTK_CONTAINER (vbox), hbox);
    gtk_widget_show (hbox);
                                  
    check = gtk_check_button_new_with_label("Editable");
    gtk_box_pack_start (GTK_BOX (hbox), check, TRUE, TRUE, 0);
    gtk_signal_connect (GTK_OBJECT(check), "toggled",
                        GTK_SIGNAL_FUNC(entry_toggle_editable), entry);
    gtk_toggle_button_set_state(GTK_TOGGLE_BUTTON(check), TRUE);
    gtk_widget_show (check);
    
    check = gtk_check_button_new_with_label("Visible");
    gtk_box_pack_start (GTK_BOX (hbox), check, TRUE, TRUE, 0);
    gtk_signal_connect (GTK_OBJECT(check), "toggled",
                        GTK_SIGNAL_FUNC(entry_toggle_visibility), entry);
    gtk_toggle_button_set_state(GTK_TOGGLE_BUTTON(check), TRUE);
    gtk_widget_show (check);
                                   
    button = gtk_button_new_with_label ("Close");
    gtk_signal_connect_object (GTK_OBJECT (button), "clicked",
                               GTK_SIGNAL_FUNC(gtk_exit),
                               GTK_OBJECT (window));
    gtk_box_pack_start (GTK_BOX (vbox), button, TRUE, TRUE, 0);
    GTK_WIDGET_SET_FLAGS (button, GTK_CAN_DEFAULT);
    gtk_widget_grab_default (button);
    gtk_widget_show (button);
    
    gtk_widget_show(window);

    gtk_main();
    return(0);
}
</PRE>
</CODE></BLOCKQUOTE>
<P>
<H2><A NAME="ss7.9">7.9 Selettori di Colore</A>
</H2>

<P>Il widget selettore di colore &egrave; chiaramente un widget che permtte di
scegliere interattivamente dei colori. Questo widget composto permette all'utente
di selezionare un colore agendo su terne RGB (Red, Green, Blue) e HSV
(Hue, Saturation, Value). Questo lo si pu&ograve; fare o agendo sui singoli valori
tramite degli slider o inserendoli da tastiera, oppure selezionando direttamente il
colore da un cerchio (valori H e S) e da una barra (valore V). 
Opzionalmente, &egrave; possibile anche stabilire il grado di trasparenza del
colore.
Il widget di selezione di colore emette per ora un solo segnale, "color_changed", che
viene generato ogni volta che il colore corrente nel widget cambia, sia quando
&egrave; l'utente a cambiarlo, sia quando viene modificato esplicitamente tramite
una chiamata a gtk_color_selection_set_color().
<P>Diamo ora un'occhiata a cosa ha da offrirci il widget di selezione di colore. 
Il widget &egrave; disponibile in due versioni, gtk_color_selection e
gtk_color_selection_dialog:
<P>
<BLOCKQUOTE><CODE>
<PRE>
GtkWidget *gtk_color_selection_new(void);
</PRE>
</CODE></BLOCKQUOTE>
<P>E' probabile che non userete questo costruttore direttamente. Infatti esso crea un
widget GtkColorSelection orfano a cui dovrete assegnare un genitore voi stessi.
Il widget GtkColorSelection  eredita dal widget GtkVBox. 
<P>
<BLOCKQUOTE><CODE>
<PRE>
 
GtkWidget *gtk_color_selection_dialog_new(const gchar *title);
</PRE>
</CODE></BLOCKQUOTE>
<P>Questo &egrave; il pi&ugrave; comune fra i costruttori di selettori di colore. Esso
crea un GtkColorSelectionDialog, che eredita da GtkDialog. Esso consiste di un
GtkFrame che contiene un widget GtkColorSelection, un GtkHSeparator e un
GtkHBox con tre bottoni, "Ok", "Cancel" e "Help". Si arriva a questi bottoni
accedendo ai widget "ok_button", "cancel_button" e "help_button" nella 
struttura GtkColorSelectionDialog (cio&egrave;  (GTK_COLOR_SELECTION_DIALOG(colorseldialog)->ok_button).
<P>
<BLOCKQUOTE><CODE>
<PRE>
void gtk_color_selection_set_update_policy(GtkColorSelection *colorsel, 
                                           GtkUpdateType policy);
</PRE>
</CODE></BLOCKQUOTE>
<P>Questa funzione stabilisce la politica di aggiornamento. Quella predefinita &egrave;
GTK_UPDATE_CONTINOUS, che significa che il colore viene aggiornato
continuamente mano a mano che l'utente trascina gli slider o preme e trascina il
mouse nel cerchio della hue-saturation o nella relativa barra. Se si hanno problemi
di prestazioni, si pu&ograve; decidere di usare la politica
GTK_UPDATE_DISCONTINOUS
o GTK_UPDATE_DELAYED.
<P>
<BLOCKQUOTE><CODE>
<PRE>
void gtk_color_selection_set_opacity(GtkColorSelection *colorsel,
                                     gint use_opacity);
</PRE>
</CODE></BLOCKQUOTE>
<P>Il widget di selezione di colore permette anche di variare l'opacit&agrave; di un
colore (conosciuta anche come canale alfa). Questa caratteristica &egrave; 
normalmente disabilitata. Chiamare la precedente funzione, con use_opacity uguale
a TRUE abilita la manipolazione dell'opacit&agrave;. Analogamente, mettendo
use_opacity uguale a FALSE la disabiliter&agrave;.
<P>
<BLOCKQUOTE><CODE>
<PRE>
void gtk_color_selection_set_color(GtkColorSelection *colorsel,
                                   gdouble *color);
</PRE>
</CODE></BLOCKQUOTE>
<P>Si pu&ograve; assegnare esplicitamente un colore chiamando questa funzione
con un puntatore ad un vettore di colori (gdouble). La lunghezza del vettore
dipende dall'attivazione o meno del controllo dell'opacit&agrave;. La posizione 0
contiene la componente rossa, la 1 \ il verde, la 2 il blu e la 3 contiene
l'opacit&agrave; (se questa \ attivata, come si &egrave; detto per
gtk_color_selection_set_opacity()). Tutti i valori sono compresi fra 0.0 e 1.0.
<P>
<BLOCKQUOTE><CODE>
<PRE>
void gtk_color_selection_get_color(GtkColorSelection *colorsel,
                                   gdouble *color);
</PRE>
</CODE></BLOCKQUOTE>
<P>Questa funzione viene usata per ottenere il colore corrente, tipicamente quando
si &egrave; ricevuto il segnale "color_changed". Color &egrave; un puntatore al
vettore di colori da riempire. Vedi la descrizione di questo vettore nella funzione
gtk_color_selection_set_color().
<P>
<P>Ecco un semplice esempio che mostra l'uso di  GtkColorSelectionDialog.
Il programma mostra una finestra che contiene un'area di disegno. Cliccandoci
sopra, si apre un dialogo di selezione di colore, e se si modifica il colore
nella finestra di dialogo verr&agrave; cambiato anche il colore dello sfondo.
<P>
<BLOCKQUOTE><CODE>
<PRE>
#include &lt;glib.h>
#include &lt;gdk/gdk.h>
#include &lt;gtk/gtk.h>

GtkWidget *colorseldlg = NULL;
GtkWidget *drawingarea = NULL;

/* gestore del cambiamento del colore */

void color_changed_cb (GtkWidget *widget, GtkColorSelection *colorsel)
{
  gdouble color[3];
  GdkColor gdk_color;
  GdkColormap *colormap;

  /* recupera la colormap dell'area di disegno */

  colormap = gdk_window_get_colormap (drawingarea->window);

  /* recupera il colore corrente */

  gtk_color_selection_get_color (colorsel,color);

  /* adattamento ad un intero unsigned di 16 bit (0..65535)
   * e inseriscili nella struttura GdkColor */

  gdk_color.red = (guint16)(color[0]*65535.0);
  gdk_color.green = (guint16)(color[1]*65535.0);
  gdk_color.blue = (guint16)(color[2]*65535.0);

  /* Alloca il colore */

  gdk_color_alloc (colormap, &amp;gdk_color);

  /* assegna il colore di sfondo della finestra */

  gdk_window_set_background (drawingarea->window, &amp;gdk_color);

  /* pulisce la finestra */

  gdk_window_clear (drawingarea->window);
}

/* gestore per l'area di disegno */

gint area_event (GtkWidget *widget, GdkEvent *event, gpointer client_data)
{
  gint handled = FALSE;
  GtkWidget *colorsel;

  /* controlliamo se abbiamo ricevuto un evento di pressione di pulsante */

  if (event->type == GDK_BUTTON_PRESS &amp;&amp; colorseldlg == NULL)
    {
      /* Si , c'e' l'evento e ancora non c'e' alcun colorseldlg! */

      handled = TRUE;

      /* Creiamo una finestra di dialogo per la selezione del colore */

      colorseldlg = gtk_color_selection_dialog_new("Select background color");

      /* Otteniamo il widget GtkColorSelection */

      colorsel = GTK_COLOR_SELECTION_DIALOG(colorseldlg)->colorsel;

      /* Facciamo la connessione al segnale "color_changed",
       * ed assegnamo i dati-utente al widget di selezione di colore */

      gtk_signal_connect(GTK_OBJECT(colorsel), "color_changed",
        (GtkSignalFunc)color_changed_cb, (gpointer)colorsel);

      /* Mostriamo il dialogo */

      gtk_widget_show(colorseldlg);
    }

  return handled;
}

/* Chiusura ed uscita dal getore */

void destroy_window (GtkWidget *widget, gpointer client_data)
{
  gtk_main_quit ();
}

/* Main */

gint main (gint argc, gchar *argv[])
{
  GtkWidget *window;

  /* Inizialliziamo il toolkit, remuoviamo gli argomenti sulla linea di
   * comando legati a gtk */

  gtk_init (&amp;argc,&amp;argv);

  /* creiamo la finestra base, con titolo e politiche */

  window = gtk_window_new (GTK_WINDOW_TOPLEVEL);
  gtk_window_set_title (GTK_WINDOW(window), "Color selection test");
  gtk_window_set_policy (GTK_WINDOW(window), TRUE, TRUE, TRUE);

  /* colleghiamo gli eventi "delete" e "destroy" per poter uscire */

  gtk_signal_connect (GTK_OBJECT(window), "delete_event",
    (GtkSignalFunc)destroy_window, (gpointer)window);

  gtk_signal_connect (GTK_OBJECT(window), "destroy",
    (GtkSignalFunc)destroy_window, (gpointer)window);
  
  /* crea un'area di disegna, stabilisce le dimensioni e raccogli 
   * gli eventi */

  drawingarea = gtk_drawing_area_new ();

  gtk_drawing_area_size (GTK_DRAWING_AREA(drawingarea), 200, 200);

  gtk_widget_set_events (drawingarea, GDK_BUTTON_PRESS_MASK);

  gtk_signal_connect (GTK_OBJECT(drawingarea), "event", 
    (GtkSignalFunc)area_event, (gpointer)drawingarea);
  
  /* aggiungi l'area di disegno alla finestra e mostrale entrambe */

  gtk_container_add (GTK_CONTAINER(window), drawingarea);

  gtk_widget_show (drawingarea);
  gtk_widget_show (window);
  
  /* entra nel ciclo principale di gtk (che non cede mai il controllo */

  gtk_main ();

  /* soddisfa i compilatori brontoloni */

  return 0;
}
</PRE>
</CODE></BLOCKQUOTE>
<P>
<H2><A NAME="ss7.10">7.10 Selezione di File (File Selections)</A>
</H2>

<P>Il widget Selezione di File &egrave; un modo rapido e semplice per mostrare una
finestra di dialogo `File'. Questa si presenta completa di bottoni Ok,
Cancel e Help, un buon modo per tagliare i tempi di programmazione.
<P>Per creare una nuova finestra di selezione file usate:
<P>
<BLOCKQUOTE><CODE>
<PRE>
GtkWidget* gtk_file_selection_new (gchar *title);
</PRE>
</CODE></BLOCKQUOTE>
<P>Per assegnare il nome del file, ad esempio per predisporre una certa
directory o per dare un certo nome di file per difetto, usate la seguente
funzione:
<P>
<BLOCKQUOTE><CODE>
<PRE>
void gtk_file_selection_set_filename (GtkFileSelection *filesel, gchar *filename);
</PRE>
</CODE></BLOCKQUOTE>
<P>Per recuperare il testo che l'utente ha inserito o che ha selezionato con
il mouse, si usa la funzione:
<P>
<BLOCKQUOTE><CODE>
<PRE>
gchar* gtk_file_selection_get_filename (GtkFileSelection *filesel);
</PRE>
</CODE></BLOCKQUOTE>
<P>Ci sono anche dei puntatori ai widget che sono contenuti all'interno
del widget di selezione file. Si tratta di:
<P>
<UL>
<LI>dir_list</LI>
<LI>file_list</LI>
<LI>selection_entry</LI>
<LI>selection_text</LI>
<LI>main_vbox</LI>
<LI>ok_button</LI>
<LI>cancel_button</LI>
<LI>help_button</LI>
</UL>
<P>Molto probabilmente potreste voler usare i puntatori a ok_button,
cancel_button e help_button per segnalarne l'uso.
<P>Ecco un esempio rubato da testgtk.c, nodificato per essere eseguito da
solo. Come potrete vedere, non c'&egrave; molto pi&ugrave; che la creazione di un
widget di selezione file. In questo esempio, il bottone Help non fa nulla
mentre &egrave; mostrato allo schermo, dal momento che non c'&egrave; alcun segnale
collegato con esso. 
<P>
<BLOCKQUOTE><CODE>
<PRE>
/* filesel.c */

#include &lt;gtk/gtk.h>

/* Recupera il nome di file selezionato e stampalo a console */
void file_ok_sel (GtkWidget *w, GtkFileSelection *fs)
{
    g_print ("%s\n", gtk_file_selection_get_filename (GTK_FILE_SELECTION (fs)));
}

void destroy (GtkWidget *widget, gpointer data)
{
    gtk_main_quit ();
}

int main (int argc, char *argv[])
{
    GtkWidget *filew;
    
    gtk_init (&amp;argc, &amp;argv);
    
    /* Crea un nuovo widget di selezione file */
    filew = gtk_file_selection_new ("File selection");
    
    gtk_signal_connect (GTK_OBJECT (filew), "destroy",
                        (GtkSignalFunc) destroy, &amp;filew);
    /* Connette ok_button alla funzione file_ok_sel */
    gtk_signal_connect (GTK_OBJECT (GTK_FILE_SELECTION (filew)->ok_button),
                        "clicked", (GtkSignalFunc) file_ok_sel, filew );
    
    /* Connette cancel_button alla funzione di distruzione del widget */
    gtk_signal_connect_object (GTK_OBJECT (GTK_FILE_SELECTION (filew)->cancel_button),
                               "clicked", (GtkSignalFunc) gtk_widget_destroy,
                               GTK_OBJECT (filew));
    
    /* Preassegnamo un nome di file, come se stessimo dando un valore per difetto in 
    dialogo di tipo `` salva con nome '' */
    gtk_file_selection_set_filename (GTK_FILE_SELECTION(filew), 
                                     "penguin.png");
    
    gtk_widget_show(filew);
    gtk_main ();
    return 0;
}
</PRE>
</CODE></BLOCKQUOTE>
<P>
<HR NOSHADE>
<A HREF="gtk_tut_it-8.html">Avanti</A>
<A HREF="gtk_tut_it-6.html">Indietro</A>
<A HREF="gtk_tut_it.html#toc7">Indice</A>
</BODY>
</HTML>
